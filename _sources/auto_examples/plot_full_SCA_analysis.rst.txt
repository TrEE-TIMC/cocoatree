
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_full_SCA_analysis.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_full_SCA_analysis.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_full_SCA_analysis.py:


============================================================
Perform full SCA analysis on the S1A serine protease dataset
============================================================

This example shows the full process to perform a complete coevolution
analysis in order to detect protein sectors from data importation, MSA
filtering, computation of positional and joint amino acid frequencies,
and computation of the SCA coevolution matrix.

The matrix is then decomposed into principal components and independent
component analysis is performed.

In the end, we export a fasta file of the residues contributing to the first
independent component.

.. GENERATED FROM PYTHON SOURCE LINES 18-24

.. code-block:: Python


    # Author: Margaux Jullien <margaux.jullien@univ-grenoble-alpes.fr>
    #         Nelle Varoquaux <nelle.varoquaux@univ-grenoble-alpes.fr>
    #         Ivan Junier <ivan.junier@univ-grenoble-alpes.fr>
    # License: TBD








.. GENERATED FROM PYTHON SOURCE LINES 25-26

Import necessary

.. GENERATED FROM PYTHON SOURCE LINES 26-39

.. code-block:: Python

    from cocoatree.datasets import load_S1A_serine_proteases
    from cocoatree.io import export_fasta
    from cocoatree.msa import filter_gap_seq, filter_gap_pos, seq_weights
    from cocoatree.statistics.position import aa_freq_at_pos, \
        compute_background_frequencies
    from cocoatree.statistics.pairwise import aa_joint_freq, compute_sca_matrix, \
        compute_seq_identity
    from cocoatree.deconvolution import eigen_decomp, compute_ica, \
        choose_num_components, icList
    from cocoatree.randomize import randomization
    import matplotlib.pyplot as plt
    import numpy as np








.. GENERATED FROM PYTHON SOURCE LINES 40-46

Load the dataset
----------------

We start by importing the dataset. In this case, we can directly load the S1
serine protease dataset provided in :mod:`cocoatree`. To work on your on
dataset, you can use the :fun:`cocoatree.io.load_msa` function.

.. GENERATED FROM PYTHON SOURCE LINES 46-53

.. code-block:: Python


    serine_dataset = load_S1A_serine_proteases()
    seq_id = serine_dataset["sequence_ids"]
    sequences = serine_dataset["alignment"]
    n_pos, n_seq = len(sequences[0]), len(sequences)

    print(f"The loaded MSA has {n_seq} sequences and {n_pos} positions.")




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The loaded MSA has 6970 sequences and 296 positions.




.. GENERATED FROM PYTHON SOURCE LINES 54-62

MSA filtering
-------------

We are going to clean a bit the loaded MSA by filtering both sequences and
positions.

Filter overly gapped positions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 62-67

.. code-block:: Python


    filt_seqs, pos_kept = filter_gap_pos(sequences, threshold=0.4)
    n_pos_kept = len(pos_kept)
    print(f"After filtering, we have {n_pos_kept} remaining sequences.")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    After filtering, we have 226 remaining sequences.




.. GENERATED FROM PYTHON SOURCE LINES 68-70

Filter overly gapped sequences
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 70-74

.. code-block:: Python


    seq_id_kept, seq_kept = filter_gap_seq(seq_id, filt_seqs, threshold=0.2,
                                           filtrefseq=False)








.. GENERATED FROM PYTHON SOURCE LINES 75-77

Compute the matrix of pairwise sequence identity
------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 77-88

.. code-block:: Python


    sim_matrix = compute_seq_identity(seq_kept)

    fig, ax = plt.subplots()
    m = ax.imshow(sim_matrix, vmin=0, vmax=1, cmap='inferno')
    ax.set_xlabel("sequences", fontsize=10)
    ax.set_ylabel("sequences", fontsize=10)
    ax.set_title('Matrix of pairwise sequence identity', fontweight="bold")
    cb = fig.colorbar(m)
    cb.set_label("Pairwise sequence identity", fontweight="bold")




.. image-sg:: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_001.png
   :alt: Matrix of pairwise sequence identity
   :srcset: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 89-90

Compute sequence weights

.. GENERATED FROM PYTHON SOURCE LINES 90-93

.. code-block:: Python

    weights, n_eff_seq = seq_weights(sim_matrix)
    print(f"Number of effective sequences {n_eff_seq}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of effective sequences 1205.7209863932837




.. GENERATED FROM PYTHON SOURCE LINES 94-95

compute allele frequencies

.. GENERATED FROM PYTHON SOURCE LINES 95-97

.. code-block:: Python

    aa_freq = aa_freq_at_pos(seq_kept, lambda_coef=0.03, weights=weights)








.. GENERATED FROM PYTHON SOURCE LINES 98-99

Compute background frequencies

.. GENERATED FROM PYTHON SOURCE LINES 99-101

.. code-block:: Python

    background_frequencies = compute_background_frequencies(aa_freq)








.. GENERATED FROM PYTHON SOURCE LINES 102-103

Compute joint allele frequencies

.. GENERATED FROM PYTHON SOURCE LINES 103-105

.. code-block:: Python

    fijab, fijab_ind = aa_joint_freq(seq_kept, weights=weights, lambda_coef=0.03)








.. GENERATED FROM PYTHON SOURCE LINES 106-108

Compute the SCA coevolution matrix
----------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 108-122

.. code-block:: Python


    Cijab_raw, Cij = compute_sca_matrix(joint_freqs=fijab,
                                        joint_freqs_ind=fijab_ind,
                                        aa_freq=aa_freq,
                                        background_freq=background_frequencies)

    fig, ax = plt.subplots()
    im = ax.imshow(Cij, vmin=0, vmax=1.4, cmap='inferno')

    ax.set_xlabel('Residue', fontsize=10)
    ax.set_ylabel(None)
    ax.set_title('Coevolution matrix')
    fig.colorbar(im, shrink=0.7)




.. image-sg:: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_002.png
   :alt: Coevolution matrix
   :srcset: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x7f599230e650>



.. GENERATED FROM PYTHON SOURCE LINES 123-125

Decomposition of the matrix into principal components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 125-128

.. code-block:: Python


    eigenvalues, eigenvectors = eigen_decomp(Cij)








.. GENERATED FROM PYTHON SOURCE LINES 129-130

Plot distribution of eigenvalues

.. GENERATED FROM PYTHON SOURCE LINES 130-135

.. code-block:: Python

    fig, ax = plt.subplots()
    ax.hist(eigenvalues, bins=100, color="black")
    ax.set_ylabel('Number', fontweight="bold")
    ax.set_xlabel('Eigenvalue', fontweight="bold")




.. image-sg:: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_003.png
   :alt: plot full SCA analysis
   :srcset: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Text(0.5, 23.52222222222222, 'Eigenvalue')



.. GENERATED FROM PYTHON SOURCE LINES 136-144

Select number of significant components
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We use a randomization strategy in order to select the number of components.
The function :fun:cocoatree.randomize.randomization runs the full SCA
pipeline on randomized version of the MSA. Make sure that weights and lambda
coefficient are set the same way as the when performing the analysis on the
real dataset.

.. GENERATED FROM PYTHON SOURCE LINES 144-160

.. code-block:: Python

    v_rand, l_rand = randomization(seq_kept, n_rep=10,
                                   weights=weights, lambda_coef=0.03, kmax=10)
    n_components = choose_num_components(eigenvalues, l_rand)
    print('n_components = ' + str(n_components))

    hist0, bins = np.histogram(l_rand.flatten(), bins=n_pos_kept,
                               range=(0, eigenvalues.max()))
    hist1, bins = np.histogram(eigenvalues, bins=n_pos_kept,
                               range=(0, eigenvalues.max()))

    fig, ax = plt.subplots()
    ax.bar(bins[:-1], hist1, np.diff(bins), color='k')
    ax.plot(bins[:-1], hist0/10, 'r', linewidth=3)
    ax.set_xlabel('Eigenvalues', fontweight="bold")
    ax.set_ylabel('Numbers', fontweight="bold")




.. image-sg:: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_004.png
   :alt: plot full SCA analysis
   :srcset: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    n_components = 8

    Text(47.097222222222214, 0.5, 'Numbers')



.. GENERATED FROM PYTHON SOURCE LINES 161-163

Independent component analysis (ICA)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 163-191

.. code-block:: Python


    independant_components, W = compute_ica(
        eigenvectors, kmax=n_components, learnrate=0.1,
        iterations=100000)

    # Plot results
    if n_components % 2 != 0:
        print('Uneven number of axes, discard the last one for visual \
              representation')
        n_components -= 2
    else:
        n_components -= 1

    pairs = [[x, x+1] for x in range(0, n_components, 2)]
    ncols = len(pairs)
    plt.rcParams['figure.figsize'] = 14, 8
    fig, axes = plt.subplots(nrows=2, ncols=len(pairs), tight_layout=True)
    for k, [k1, k2] in enumerate(pairs):
        ax = axes[0, k]
        ax.plot(eigenvectors[:, k1], eigenvectors[:, k2], 'ok')
        ax.set_xlabel("eigenvector %i" % (k1+1), fontsize=16)
        ax.set_ylabel("eigenvector %i" % (k2+1), fontsize=16)

        ax = axes[1, k]
        ax.plot(independant_components[:, k1], independant_components[:, k2], 'ok')
        ax.set_xlabel("independant component %i" % (k1+1), fontsize=16)
        ax.set_ylabel("independant component %i" % (k2+1), fontsize=16)




.. image-sg:: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_005.png
   :alt: plot full SCA analysis
   :srcset: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 192-193

Select residues that significantly contribute to each independent component

.. GENERATED FROM PYTHON SOURCE LINES 193-199

.. code-block:: Python

    ics, icsize, sortedpos, cutoff, scaled_pdf, all_fits = icList(
        independant_components, n_components, Cij,
        p_cut=0.95)

    print(f"Sizes of the {n_components} ICs: {icsize}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Sizes of the 7 ICs: [17, 19, 22, 9, 13, 16, 11]




.. GENERATED FROM PYTHON SOURCE LINES 200-201

Plot coevolution within and between the sectors

.. GENERATED FROM PYTHON SOURCE LINES 201-216

.. code-block:: Python

    fig, ax = plt.subplots(tight_layout=True)
    im = ax.imshow(Cij[np.ix_(sortedpos, sortedpos)], vmin=0, vmax=2,
                   interpolation='none', aspect='equal',
                   extent=[0, sum(icsize), 0, sum(icsize)], cmap='inferno')
    cb = fig.colorbar(im)
    cb.set_label("Coevolution measure")

    line_index = 0
    for i in range(n_components):
        ax.plot([line_index + icsize[i], line_index + icsize[i]],
                [0, sum(icsize)], 'w', linewidth=2)
        ax.plot([0, sum(icsize)], [sum(icsize) - line_index,
                                   sum(icsize) - line_index], 'w', linewidth=2)
        line_index += icsize[i]




.. image-sg:: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_006.png
   :alt: plot full SCA analysis
   :srcset: /auto_examples/images/sphx_glr_plot_full_SCA_analysis_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 217-218

Export fasta files of the sectors for all the sequences

.. GENERATED FROM PYTHON SOURCE LINES 218-229

.. code-block:: Python


    sector_1_pos = list(pos_kept[ics[0].items])
    sector_1 = []
    for sequence in range(len(seq_id)):
        seq = ''
        for pos in sector_1_pos:
            seq += sequences[sequence][pos]
        sector_1.append(seq)

    export_fasta(sector_1, seq_id, 'sector_1.fasta')
    # outpath needs to be defined properly








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 41.955 seconds)


.. _sphx_glr_download_auto_examples_plot_full_SCA_analysis.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/tree-timc/cocoatree/gh-pages?urlpath=lab/tree/notebooks/auto_examples/plot_full_SCA_analysis.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_full_SCA_analysis.ipynb <plot_full_SCA_analysis.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_full_SCA_analysis.py <plot_full_SCA_analysis.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_full_SCA_analysis.zip <plot_full_SCA_analysis.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
